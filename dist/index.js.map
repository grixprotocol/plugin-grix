{"version":3,"sources":["../src/actions/getAssetPrice.ts","../src/services/base.ts","../src/constants/api.ts","../src/types/error.ts","../src/constants/errors.ts","../src/services/price.ts","../src/services/option.ts","../src/services/signal.ts","../src/services/index.ts","../src/environment.ts","../src/actions/getOptionPrice.ts","../src/actions/getTradingSignal.ts","../src/actions/showGrixHelp.ts","../src/index.ts"],"sourcesContent":["import {\n\ttype Action,\n\tcomposeContext,\n\telizaLogger,\n\tgenerateObjectDeprecated,\n\ttype HandlerCallback,\n\ttype IAgentRuntime,\n\ttype Memory,\n\tModelClass,\n\ttype State,\n} from \"@elizaos/core\";\nimport { GrixService } from \"../services\";\nimport { validateGrixConfig } from \"../environment\";\nimport { ASSET_TYPES } from \"../constants/api\";\n\nconst assetPriceTemplate = `Extract the cryptocurrency from the user's request.\nIf not specified, default to BTC.\n\nExamples of user requests and their parameters:\n- \"What's the current Bitcoin price?\" -> {\"asset\": \"BTC\"}\n- \"Show me ETH price\" -> {\"asset\": \"ETH\"}\n- \"How much is Ethereum worth?\" -> {\"asset\": \"ETH\"}\n- \"Check BTC price\" -> {\"asset\": \"BTC\"}\n- \"What's the price right now?\" -> {\"asset\": \"BTC\"}\n\nLook for these indicators:\n- BTC/Bitcoin/btc\n- ETH/Ethereum/eth\n\nUser's request: \"{{recentMessages}}\"\n\nReturn ONLY a JSON object with the parameter:\n{\n    \"asset\": \"BTC\" or \"ETH\"\n}`;\n\nexport const getAssetPriceAction: Action = {\n\tname: \"GET_ASSET_PRICE\",\n\tsimiles: [\"CHECK_PRICE\", \"PRICE_CHECK\", \"TOKEN_PRICE\", \"CRYPTO_PRICE\"],\n\tdescription: \"Get current price for a cryptocurrency\",\n\tvalidate: async (runtime: IAgentRuntime) => {\n\t\ttry {\n\t\t\tawait validateGrixConfig(runtime);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t},\n\thandler: async (\n\t\truntime: IAgentRuntime,\n\t\tmessage: Memory,\n\t\tstate?: State,\n\t\t_options?: { [key: string]: unknown },\n\t\tcallback?: HandlerCallback\n\t): Promise<boolean> => {\n\t\ttry {\n\t\t\telizaLogger.warn(\"ðŸš€ Starting getAssetPrice handler\");\n\n\t\t\tconst config = await validateGrixConfig(runtime);\n\t\t\tconst grixService = new GrixService({ apiKey: config.GRIX_API_KEY });\n\n\t\t\tconst extractedParams = await generateObjectDeprecated({\n\t\t\t\truntime,\n\t\t\t\tcontext: assetPriceTemplate.replace(\"{{recentMessages}}\", message.content.text),\n\t\t\t\tmodelClass: ModelClass.SMALL,\n\t\t\t});\n\n\t\t\telizaLogger.warn(\"ðŸŽ¯ Extracted asset parameters:\", extractedParams);\n\n\t\t\tconst normalizedParams = {\n\t\t\t\tasset: (extractedParams.asset || \"BTC\").toUpperCase(),\n\t\t\t};\n\n\t\t\telizaLogger.warn(\"ðŸ”„ Normalized parameters:\", normalizedParams);\n\n\t\t\tconst result = await grixService.getPrice(normalizedParams);\n\n\t\t\tif (callback) {\n\t\t\t\tawait callback({\n\t\t\t\t\ttext: `The current ${result.asset} price is ${result.formattedPrice}`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (state) {\n\t\t\t\tstate.responseData = { text: result.formattedPrice, action: \"GET_ASSET_PRICE\" };\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\telizaLogger.error(\"Error in GET_ASSET_PRICE action:\", error);\n\t\t\tif (callback) {\n\t\t\t\tawait callback({\n\t\t\t\t\ttext: `Sorry, I couldn't get the price. Error: ${error}`,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\texamples: [\n\t\t[\n\t\t\t{\n\t\t\t\tuser: \"{{user1}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"What's the current Bitcoin price?\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"I'll check the current Bitcoin price for you.\",\n\t\t\t\t\taction: \"GET_ASSET_PRICE\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"The current BTC price is $42,150.25\",\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t\t[\n\t\t\t{\n\t\t\t\tuser: \"{{user1}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"How much is ETH worth right now?\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"I'll check the current Ethereum price for you.\",\n\t\t\t\t\taction: \"GET_ASSET_PRICE\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"The current ETH price is $2,245.80\",\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t],\n};\n","import { elizaLogger } from \"@elizaos/core\";\nimport { GrixSDK } from \"@grixprotocol/sdk\";\nimport { API_DEFAULTS } from \"../constants/api\";\nimport { ApiError, AuthenticationError, GrixError } from \"../types/error\";\n\nexport interface ServiceOptions {\n\ttimeout?: number;\n\tapiKey?: string;\n}\n\nexport abstract class BaseService {\n\tprotected sdk: GrixSDK | null = null;\n\tprotected apiKey: string | undefined;\n\tprotected timeout: number;\n\n\tconstructor(options?: ServiceOptions) {\n\t\tthis.apiKey = options?.apiKey;\n\t\tthis.timeout = options?.timeout || API_DEFAULTS.TIMEOUT;\n\t}\n\n\t/**\n\t * Initialize the SDK instance if needed\n\t */\n\tprotected async getSDK(): Promise<GrixSDK> {\n\t\telizaLogger.info(\"ðŸ”Œ Initializing Grix SDK...\");\n\t\tif (!this.sdk) {\n\t\t\tthis.validateApiKey();\n\t\t\ttry {\n\t\t\t\telizaLogger.info(\"Creating new SDK instance...\");\n\t\t\t\tthis.sdk = await GrixSDK.initialize({\n\t\t\t\t\tapiKey: this.apiKey as string,\n\t\t\t\t});\n\t\t\t\telizaLogger.info(\"âœ… SDK initialized successfully\");\n\t\t\t} catch (error) {\n\t\t\t\telizaLogger.error(\"âŒ SDK initialization failed:\", error);\n\t\t\t\tthrow this.handleError(error, \"SDK initialization\");\n\t\t\t}\n\t\t}\n\t\treturn this.sdk;\n\t}\n\n\t/**\n\t * Validate API key presence\n\t */\n\tprotected validateApiKey(): void {\n\t\tif (!this.apiKey) {\n\t\t\tthrow new AuthenticationError();\n\t\t}\n\t}\n\n\t/**\n\t * Standardized error handling for service errors\n\t */\n\tprotected handleError(error: unknown, context?: string): Error {\n\t\telizaLogger.error(`ðŸš¨ Error in ${context || \"unknown context\"}:`, error);\n\n\t\t// If it's already a GrixError or Error, return it\n\t\tif (error instanceof GrixError || error instanceof Error) {\n\t\t\treturn error;\n\t\t}\n\n\t\t// Convert unknown error to ApiError\n\t\tconst message = error?.toString() || \"Unknown error\";\n\t\tconst contextStr = context ? ` during ${context}` : \"\";\n\t\treturn new ApiError(`Grix API error${contextStr}: ${message}`, 500);\n\t}\n}\n","export const API_DEFAULTS = {\n\tBASE_URL: \"https://api.grix.finance\",\n\tTIMEOUT: 30000, // 30 seconds\n\tRATE_LIMIT: {\n\t\tMAX_REQUESTS_PER_MINUTE: 100,\n\t\tWEIGHT_PER_REQUEST: 1,\n\t},\n};\n\nexport const OPTION_TYPES = {\n\tCALL: \"call\",\n\tPUT: \"put\",\n} as const;\n\nexport const POSITION_TYPES = {\n\tLONG: \"long\",\n\tSHORT: \"short\",\n} as const;\n\nexport const ASSET_TYPES = {\n\tBTC: \"BTC\",\n\tETH: \"ETH\",\n} as const; ","export class GrixError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'GrixError';\n    }\n}\n\nexport class AuthenticationError extends GrixError {\n    constructor(message = 'Authentication failed. Please check your API credentials.') {\n        super(message);\n        this.name = 'AuthenticationError';\n    }\n}\n\nexport class InvalidParameterError extends GrixError {\n    constructor(message: string) {\n        super(message);\n        this.name = 'InvalidParameterError';\n    }\n}\n\nexport class ServiceUnavailableError extends GrixError {\n    constructor(message = 'The Grix service is currently unavailable. Please try again later.') {\n        super(message);\n        this.name = 'ServiceUnavailableError';\n    }\n}\n\nexport class ApiError extends GrixError {\n    public code: number;\n    public response?: unknown;\n\n    constructor(message: string, code: number, response?: unknown) {\n        super(message);\n        this.name = 'ApiError';\n        this.code = code;\n        this.response = response;\n    }\n} ","export const ERROR_CODES = {\n\tINVALID_CREDENTIALS: 401,\n\tINVALID_PARAMETERS: 400,\n\tSERVICE_UNAVAILABLE: 503,\n} as const;\n\nexport const ERROR_MESSAGES = {\n\tINVALID_CREDENTIALS: \"Invalid API credentials. Please check your API key.\",\n\tINVALID_ASSET: \"Invalid asset. Only BTC and ETH are supported.\",\n\tINVALID_OPTION_TYPE: \"Invalid option type. Only 'call' and 'put' are supported.\",\n\tINVALID_POSITION_TYPE: \"Invalid position type. Only 'long' and 'short' are supported.\",\n\tSERVICE_UNAVAILABLE: \"The Grix service is currently unavailable. Please try again later.\",\n\tOPTION_FETCH_ERROR: (asset: string) => `Failed to fetch options data for ${asset}`,\n\tPRICE_FETCH_ERROR: (asset: string) => `Failed to fetch price for ${asset}`,\n} as const; ","import { BaseService } from \"./base\";\nimport { ASSET_TYPES } from \"../constants/api\";\nimport { ERROR_MESSAGES } from \"../constants/errors\";\nimport { InvalidParameterError } from \"../types/error\";\nimport type { ServiceOptions } from \"./base\";\n\nexport interface PriceResponse {\n    asset: string;\n    price: number;\n    formattedPrice: string;\n    timestamp: number;\n}\n\nexport interface PriceRequest {\n    asset: string;\n}\n\nexport class PriceService extends BaseService {\n    constructor(options?: ServiceOptions) {\n        super(options);\n    }\n\n    /**\n     * Get current price for a cryptocurrency\n     */\n    async getPrice(request: PriceRequest): Promise<PriceResponse> {\n        try {\n            this.validateAsset(request.asset);\n            \n            const sdk = await this.getSDK();\n            const assetName = request.asset.toLowerCase() === 'btc' ? 'bitcoin' : 'ethereum';\n            \n            const price = await sdk.fetchAssetPrice(assetName);\n            \n            return {\n                asset: request.asset.toUpperCase(),\n                price,\n                formattedPrice: this.formatPrice(price),\n                timestamp: Date.now()\n            };\n        } catch (error) {\n            throw this.handleError(error, `price fetch for ${request.asset}`);\n        }\n    }\n\n    /**\n     * Validate asset is supported\n     */\n    private validateAsset(asset: string): void {\n        const normalizedAsset = asset.toUpperCase();\n        const validAssets = Object.values(ASSET_TYPES);\n        \n        if (!validAssets.includes(normalizedAsset as any)) {\n            throw new InvalidParameterError(ERROR_MESSAGES.INVALID_ASSET);\n        }\n    }\n\n    /**\n     * Format price for display\n     */\n    private formatPrice(price: number): string {\n        return new Intl.NumberFormat('en-US', {\n            style: 'currency',\n            currency: 'USD'\n        }).format(price);\n    }\n} ","import { BaseService } from \"./base\";\nimport { ASSET_TYPES, OPTION_TYPES, POSITION_TYPES } from \"../constants/api\";\nimport { ERROR_MESSAGES } from \"../constants/errors\";\nimport { InvalidParameterError } from \"../types/error\";\nimport type { ServiceOptions } from \"./base\";\nimport { UnderlyingAsset, OptionType, PositionType } from \"@grixprotocol/sdk\";\nimport { elizaLogger } from \"@elizaos/core\";\n\ninterface OptionData {\n\toptionId: number;\n\tsymbol: string;\n\ttype: string;\n\texpiry: string;\n\tstrike: number;\n\tprotocol: string;\n\tmarketName: string;\n\tcontractPrice: number;\n\tavailableAmount: string;\n}\n\nexport interface OptionRequest {\n\tasset: string;\n\toptionType: string;\n\tpositionType?: string;\n\tstrike?: number;\n\texpiry?: string;\n\tlimit?: number;\n}\n\nexport interface OptionResponse {\n\tasset: string;\n\toptionType: string;\n\tformattedOptions: string;\n\toptions: {\n\t\toptionId: number;\n\t\texpiry: string;\n\t\tstrike: number;\n\t\tprice: number;\n\t\tprotocol: string;\n\t\tavailable: number;\n\t\ttype: string;\n\t}[];\n\ttimestamp: number;\n}\n\nexport class OptionService extends BaseService {\n\tprivate optionsCache: OptionData[] = [];\n\tprivate lastFetchTime: number = 0;\n\tprivate static CACHE_DURATION = 60000; // 1 minute cache\n\n\tconstructor(options?: ServiceOptions) {\n\t\tsuper(options);\n\t}\n\n\t/**\n\t * Get option data for a cryptocurrency\n\t */\n\tasync getOptions(request: {\n\t\tasset: string;\n\t\toptionType?: string;\n\t\tpositionType?: string;\n\t\tstrike?: number;\n\t\texpiry?: string;\n\t}) {\n\t\ttry {\n\t\t\telizaLogger.warn(\"ðŸš€ Starting getOptions with request:\", {\n\t\t\t\t...request,\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t});\n\n\t\t\tconst sdk = await this.getSDK();\n\t\t\tconst asset =\n\t\t\t\trequest.asset.toUpperCase() === \"BTC\" ? UnderlyingAsset.BTC : UnderlyingAsset.ETH;\n\t\t\tconst optionType = request.optionType === \"call\" ? OptionType.call : OptionType.put;\n\t\t\tconst positionType = request.positionType === \"long\" ? \"long\" : \"short\";\n\t\t\t// Fetch and cache options data if needed\n\t\t\tif (this.shouldRefreshCache()) {\n\t\t\t\telizaLogger.warn(\"ðŸ“¡ Fetching options data for asset:\", asset);\n\t\t\t\tconst response = await sdk.getOptionsMarketBoard({\n\t\t\t\t\tasset,\n\t\t\t\t\toptionType: optionType,\n\t\t\t\t\tpositionType: positionType as PositionType,\n\t\t\t\t});\n\n\t\t\t\telizaLogger.warn(\"ðŸ“¥ Received response array:\", response);\n\n\t\t\t\tconst transformedOptions = this.transformOptionsData(response);\n\t\t\t\telizaLogger.warn(\"ðŸ”„ Transformed options count:\", transformedOptions.length);\n\n\t\t\t\tthis.optionsCache = transformedOptions.map((opt) => ({\n\t\t\t\t\toptionId: opt.optionId,\n\t\t\t\t\tsymbol: asset,\n\t\t\t\t\ttype: opt.type,\n\t\t\t\t\texpiry: opt.expiry,\n\t\t\t\t\tstrike: opt.strike,\n\t\t\t\t\tprotocol: opt.protocol,\n\t\t\t\t\tmarketName: opt.protocol,\n\t\t\t\t\tcontractPrice: opt.price,\n\t\t\t\t\tavailableAmount: opt.available.toString(),\n\t\t\t\t}));\n\t\t\t\telizaLogger.info(\n\t\t\t\t\t\"ðŸ’¾ Updated cache with options:\",\n\t\t\t\t\tJSON.stringify(this.optionsCache, null, 2)\n\t\t\t\t);\n\t\t\t\tthis.lastFetchTime = Date.now();\n\t\t\t}\n\n\t\t\t// Log filtering steps\n\t\t\telizaLogger.info(\"ðŸ” Starting options filtering...\");\n\t\t\tlet filteredOptions = this.optionsCache;\n\n\t\t\tif (request.optionType) {\n\t\t\t\telizaLogger.info(`Filtering by option type: ${request.optionType}`);\n\t\t\t\tfilteredOptions = filteredOptions.filter(\n\t\t\t\t\t(opt) => opt.type.toLowerCase() === request.optionType?.toLowerCase()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\telizaLogger.info(`âœ¨ Final filtered options count: ${filteredOptions.length}`);\n\t\t\telizaLogger.info(\"ðŸ“¤ Returning options response\");\n\n\t\t\tconst response = {\n\t\t\t\tasset: request.asset,\n\t\t\t\toptionType: request.optionType || \"all\",\n\t\t\t\tformattedOptions: this.formatOptionsResponse(filteredOptions),\n\t\t\t\toptions: filteredOptions.map((opt) => ({\n\t\t\t\t\toptionId: opt.optionId,\n\t\t\t\t\texpiry: opt.expiry,\n\t\t\t\t\tstrike: opt.strike,\n\t\t\t\t\tprice: opt.contractPrice,\n\t\t\t\t\tprotocol: opt.protocol,\n\t\t\t\t\tavailable: parseFloat(opt.availableAmount),\n\t\t\t\t\ttype: opt.type,\n\t\t\t\t})),\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t};\n\n\t\t\t// Log the final response\n\t\t\telizaLogger.warn(\"ðŸ“¦ Final response summary:\", {\n\t\t\t\tasset: request.asset,\n\t\t\t\toptionType: request.optionType || \"all\",\n\t\t\t\toptionsCount: filteredOptions.length,\n\t\t\t});\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\telizaLogger.error(\"âŒ Error:\", error);\n\t\t\tthrow this.handleError(error, \"options fetch\");\n\t\t}\n\t}\n\n\tprivate shouldRefreshCache(): boolean {\n\t\treturn Date.now() - this.lastFetchTime > OptionService.CACHE_DURATION;\n\t}\n\n\t// Helper methods for querying cached data\n\tasync getExpiryDates(): Promise<string[]> {\n\t\tconst uniqueExpiries = [...new Set(this.optionsCache.map((opt) => opt.expiry))];\n\t\treturn uniqueExpiries.sort();\n\t}\n\n\tasync getStrikePrices(expiry?: string): Promise<number[]> {\n\t\tlet options = this.optionsCache;\n\t\tif (expiry) {\n\t\t\toptions = options.filter((opt) => opt.expiry === expiry);\n\t\t}\n\t\tconst uniqueStrikes = [...new Set(options.map((opt) => opt.strike))];\n\t\treturn uniqueStrikes.sort((a, b) => a - b);\n\t}\n\n\tasync getProtocols(): Promise<string[]> {\n\t\treturn [...new Set(this.optionsCache.map((opt) => opt.protocol))];\n\t}\n\n\t/**\n\t * Validate option request parameters\n\t */\n\tprivate validateRequest(request: OptionRequest): void {\n\t\telizaLogger.info(\"ðŸ” Validating option request:\", request);\n\n\t\t// Validate asset\n\t\tconst normalizedAsset = request.asset.toUpperCase();\n\t\telizaLogger.info(\"Validating asset:\", normalizedAsset);\n\t\tconst validAssets = Object.values(ASSET_TYPES);\n\t\tif (!validAssets.includes(normalizedAsset as any)) {\n\t\t\telizaLogger.error(\"âŒ Invalid asset:\", normalizedAsset);\n\t\t\tthrow new InvalidParameterError(ERROR_MESSAGES.INVALID_ASSET);\n\t\t}\n\n\t\t// Validate option type\n\t\tconst normalizedOptionType = request.optionType.toLowerCase();\n\t\telizaLogger.info(\"Validating option type:\", normalizedOptionType);\n\t\tconst validOptionTypes = Object.values(OPTION_TYPES);\n\t\tif (!validOptionTypes.includes(normalizedOptionType as any)) {\n\t\t\telizaLogger.error(\"âŒ Invalid option type:\", normalizedOptionType);\n\t\t\tthrow new InvalidParameterError(ERROR_MESSAGES.INVALID_OPTION_TYPE);\n\t\t}\n\n\t\t// Validate position type if provided\n\t\tif (request.positionType) {\n\t\t\tconst normalizedPositionType = request.positionType.toLowerCase();\n\t\t\tconst validPositionTypes = Object.values(POSITION_TYPES);\n\t\t\tif (!validPositionTypes.includes(normalizedPositionType as any)) {\n\t\t\t\tthrow new InvalidParameterError(ERROR_MESSAGES.INVALID_POSITION_TYPE);\n\t\t\t}\n\t\t}\n\n\t\telizaLogger.info(\"âœ… Request validation successful\");\n\t}\n\n\t/**\n\t * Transform raw options data into standardized format\n\t */\n\tprivate transformOptionsData(apiResponse: any): OptionResponse[\"options\"] {\n\t\telizaLogger.warn(\"ðŸ”„ Starting options data transformation\");\n\n\t\tif (!Array.isArray(apiResponse)) {\n\t\t\telizaLogger.warn(\"âš ï¸ Response is not an array\");\n\t\t\treturn [];\n\t\t}\n\n\t\telizaLogger.warn(`ðŸ“Š Processing ${apiResponse.length} options`);\n\n\t\tconst options = apiResponse.map((option: any) => ({\n\t\t\texpiry: option.expiry,\n\t\t\tstrike: option.strike,\n\t\t\tprice: option.contractPrice,\n\t\t\tprotocol: option.protocol,\n\t\t\tavailable: parseFloat(option.availableAmount),\n\t\t\ttype: option.type,\n\t\t\toptionId: option.optionId,\n\t\t}));\n\n\t\telizaLogger.warn(`âœ… Transformed ${options.length} options successfully`);\n\t\treturn options;\n\t}\n\n\tprivate formatOptionSymbol(option: OptionData): string {\n\t\tconst date = new Date(option.expiry);\n\t\tconst day = date.getDate().toString().padStart(2, \"0\");\n\t\tconst month = date.toLocaleString(\"en-US\", { month: \"short\" }).toUpperCase();\n\t\tconst year = date.getFullYear().toString().slice(-2);\n\t\tconst type = option.type.charAt(0); // 'C' for CALL, 'P' for PUT\n\n\t\treturn `${option.symbol}-${day}${month}${year}-${option.strike}-${type}`;\n\t}\n\n\tprivate formatOptionsResponse(options: OptionData[]): string {\n\t\tif (options.length === 0) {\n\t\t\treturn \"No options available\";\n\t\t}\n\n\t\t// Group by expiry date\n\t\tconst groupedByExpiry = options.reduce((acc, opt) => {\n\t\t\tconst expiry = opt.expiry;\n\t\t\tif (!acc[expiry]) {\n\t\t\t\tacc[expiry] = [];\n\t\t\t}\n\t\t\tacc[expiry].push(opt);\n\t\t\treturn acc;\n\t\t}, {} as Record<string, OptionData[]>);\n\n\t\tlet response = \"\";\n\t\tObject.entries(groupedByExpiry).forEach(([expiry, expiryOptions]) => {\n\t\t\tresponse += `\\nExpiry: ${expiry}\\n`;\n\t\t\texpiryOptions.forEach((option) => {\n\t\t\t\tconst symbol = this.formatOptionSymbol(option);\n\t\t\t\tresponse += `\\n${symbol}\\n`;\n\t\t\t\tresponse += `Protocol: ${option.protocol}\\n`;\n\t\t\t\tresponse += `Available: ${option.availableAmount} contracts\\n`;\n\t\t\t\tresponse += `Price: $${option.contractPrice.toLocaleString()}\\n`;\n\t\t\t\tresponse += `------------------------\\n`;\n\t\t\t});\n\t\t});\n\n\t\treturn response.trim();\n\t}\n}\n","import { BaseService } from \"./base\";\nimport { ASSET_TYPES } from \"../constants/api\";\nimport { ERROR_MESSAGES } from \"../constants/errors\";\nimport { InvalidParameterError } from \"../types/error\";\nimport type { ServiceOptions } from \"./base\";\nimport { UnderlyingAsset } from \"@grixprotocol/sdk\";\nimport { elizaLogger } from \"@elizaos/core\";\n\nexport interface TradingSignalRequest {\n\tasset: string;\n\tbudget_usd: number;\n\ttrade_window_ms: number;\n\trisk_level: \"conservative\" | \"moderate\" | \"aggressive\";\n\tstrategy_focus: \"income\" | \"growth\" | \"hedging\";\n}\n\nexport interface SignalResponse {\n\tsignals: Array<{\n\t\tid: string;\n\t\taction_type: string;\n\t\tposition_type: string;\n\t\tinstrument: string;\n\t\tinstrument_type: string;\n\t\tsize: number;\n\t\texpected_instrument_price_usd: number;\n\t\texpected_total_price_usd: number;\n\t\treason: string;\n\t\ttarget_position_id: string;\n\t\tcreated_at: number;\n\t\tupdated_at: number;\n\t}>;\n\ttimestamp: number;\n}\n\ninterface SignalData {\n\tid: string;\n\tsignal: {\n\t\taction_type: string;\n\t\tposition_type: string;\n\t\tinstrument: string;\n\t\tinstrument_type: string;\n\t\tsize: number;\n\t\texpected_instrument_price_usd: number;\n\t\texpected_total_price_usd: number;\n\t\treason: string;\n\t\ttarget_position_id: string | null;\n\t};\n\tcreated_at: string;\n\tupdated_at: string;\n}\n\nexport class SignalService extends BaseService {\n\tprivate static DEFAULT_AGENT_CONFIG = {\n\t\tagent_name: \"OS-E\",\n\t\tis_simulation: true,\n\t\tsignal_request_config: {\n\t\t\tprotocols: [\"derive\", \"aevo\", \"premia\", \"moby\", \"ithaca\", \"zomma\", \"deribit\"],\n\t\t\tinput_data: [\"marketData\", \"assetPrices\"],\n\t\t\tcontext_window_ms: 604800000, // 1 week\n\t\t},\n\t};\n\n\tprivate static MAX_RETRIES = 10;\n\tprivate static RETRY_DELAY = 2000; // 2 seconds\n\n\tconstructor(options?: ServiceOptions) {\n\t\tsuper(options);\n\t}\n\n\tprivate async waitForSignals(agentId: number | string): Promise<any> {\n\t\tlet retries = 0;\n\n\t\twhile (retries < SignalService.MAX_RETRIES) {\n\t\t\tconst result = await this.getSDK().then((sdk) =>\n\t\t\t\tsdk.getTradeSignals({ agentId: agentId.toString() })\n\t\t\t);\n\n\t\t\tconst signalRequest = result.personalAgents[0]?.signal_requests[0];\n\t\t\tif (signalRequest?.progress === \"completed\" && signalRequest?.signals?.length > 0) {\n\t\t\t\telizaLogger.info(\"Signals generated successfully\");\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\telizaLogger.info(\n\t\t\t\t`Waiting for signals... (attempt ${retries + 1}/${SignalService.MAX_RETRIES})`\n\t\t\t);\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, SignalService.RETRY_DELAY));\n\t\t\tretries++;\n\t\t}\n\n\t\tthrow new Error(\"Timeout waiting for signals\");\n\t}\n\n\t/**\n\t * Generate trading signals based on configuration\n\t */\n\tasync generateSignals(request: TradingSignalRequest): Promise<SignalResponse> {\n\t\ttry {\n\t\t\telizaLogger.info(\"Generating trading signals for request:\", request);\n\t\t\tthis.validateRequest(request);\n\n\t\t\tconst sdk = await this.getSDK();\n\n\t\t\t// Create trade agent\n\t\t\tconst createRequest = {\n\t\t\t\townerAddress: \"default\",\n\t\t\t\tconfig: {\n\t\t\t\t\t...SignalService.DEFAULT_AGENT_CONFIG,\n\t\t\t\t\tsignal_request_config: {\n\t\t\t\t\t\t...SignalService.DEFAULT_AGENT_CONFIG.signal_request_config,\n\t\t\t\t\t\tbudget_usd: request.budget_usd.toString(),\n\t\t\t\t\t\tassets: [request.asset],\n\t\t\t\t\t\ttrade_window_ms: request.trade_window_ms,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\telizaLogger.info(\n\t\t\t\t\"Creating trade agent with request:\",\n\t\t\t\tJSON.stringify(createRequest, null, 2)\n\t\t\t);\n\t\t\tconst { agentId } = await sdk.createTradeAgent(createRequest);\n\t\t\telizaLogger.info(\"Created trade agent with ID:\", agentId);\n\n\t\t\t// Request signals\n\t\t\tconst signalRequest = {\n\t\t\t\tconfig: {\n\t\t\t\t\tbudget_usd: request.budget_usd.toString(),\n\t\t\t\t\tassets: [request.asset],\n\t\t\t\t\ttrade_window_ms: request.trade_window_ms,\n\t\t\t\t\tcontext_window_ms: 604800000,\n\t\t\t\t\tinput_data: [\"marketData\", \"assetPrices\"],\n\t\t\t\t\tprotocols: [\"derive\", \"aevo\", \"premia\", \"moby\", \"ithaca\", \"zomma\", \"deribit\"],\n\t\t\t\t\tuser_prompt: `Generate ${request.risk_level} ${request.strategy_focus} strategies`,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\telizaLogger.info(\"Requesting trade agent signals with:\", {\n\t\t\t\tagentId,\n\t\t\t\trequest: JSON.stringify(signalRequest, null, 2),\n\t\t\t});\n\t\t\tawait sdk.requestTradeAgentSignals(Number(agentId), signalRequest);\n\t\t\telizaLogger.info(\"Successfully requested signals for agent:\", agentId);\n\t\t\tconst result = await this.waitForSignals(agentId);\n\t\t\tconst allSignals = result.personalAgents[0].signal_requests[0].signals;\n\n\t\t\treturn {\n\t\t\t\tsignals: allSignals.map((s: SignalData) => ({\n\t\t\t\t\tid: s.id,\n\t\t\t\t\taction_type: s.signal.action_type,\n\t\t\t\t\tposition_type: s.signal.position_type,\n\t\t\t\t\tinstrument: s.signal.instrument,\n\t\t\t\t\tinstrument_type: s.signal.instrument_type,\n\t\t\t\t\tsize: s.signal.size,\n\t\t\t\t\texpected_instrument_price_usd: s.signal.expected_instrument_price_usd,\n\t\t\t\t\texpected_total_price_usd: s.signal.expected_total_price_usd,\n\t\t\t\t\treason: s.signal.reason,\n\t\t\t\t\ttarget_position_id: s.signal.target_position_id,\n\t\t\t\t\tcreated_at: s.created_at,\n\t\t\t\t\tupdated_at: s.updated_at,\n\t\t\t\t})),\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t};\n\t\t} catch (error) {\n\t\t\telizaLogger.error(\"Error generating signals:\", error);\n\t\t\tthrow this.handleError(error, `signal generation for ${request.asset}`);\n\t\t}\n\t}\n\n\t/**\n\t * Validate trading signal request parameters\n\t */\n\tprivate validateRequest(request: TradingSignalRequest): void {\n\t\t// Validate asset\n\t\tconst normalizedAsset = request.asset.toUpperCase();\n\t\tconst validAssets = Object.values(ASSET_TYPES);\n\t\tif (!validAssets.includes(normalizedAsset as any)) {\n\t\t\tthrow new InvalidParameterError(ERROR_MESSAGES.INVALID_ASSET);\n\t\t}\n\n\t\t// Validate budget (must be positive)\n\t\tif (request.budget_usd <= 0) {\n\t\t\tthrow new InvalidParameterError(\"Budget must be greater than zero\");\n\t\t}\n\n\t\t// Validate time window (must be positive)\n\t\tif (request.trade_window_ms <= 0) {\n\t\t\tthrow new InvalidParameterError(\"Trading window must be greater than zero\");\n\t\t}\n\n\t\t// Risk level validation\n\t\tconst validRiskLevels = [\"conservative\", \"moderate\", \"aggressive\"];\n\t\tif (!validRiskLevels.includes(request.risk_level)) {\n\t\t\tthrow new InvalidParameterError(\n\t\t\t\t`Invalid risk level. Must be one of: ${validRiskLevels.join(\", \")}`\n\t\t\t);\n\t\t}\n\n\t\t// Strategy focus validation\n\t\tconst validFocuses = [\"income\", \"growth\", \"hedging\"];\n\t\tif (!validFocuses.includes(request.strategy_focus)) {\n\t\t\tthrow new InvalidParameterError(\n\t\t\t\t`Invalid strategy focus. Must be one of: ${validFocuses.join(\", \")}`\n\t\t\t);\n\t\t}\n\t}\n}\n","import type { ServiceOptions } from \"./base\";\nimport { PriceService } from \"./price\";\nimport { OptionService } from \"./option\";\nimport { SignalService } from \"./signal\";\n\n/**\n * Main service facade that coordinates between specialized services\n */\nexport class GrixService {\n\tprivate priceService: PriceService;\n\tprivate optionService: OptionService;\n\tprivate signalService: SignalService;\n\n\tconstructor(options?: ServiceOptions) {\n\t\tthis.priceService = new PriceService(options);\n\t\tthis.optionService = new OptionService(options);\n\t\tthis.signalService = new SignalService(options);\n\t}\n\n\tstatic formatPrice(price: number): string {\n\t\treturn new Intl.NumberFormat(\"en-US\", {\n\t\t\tstyle: \"currency\",\n\t\t\tcurrency: \"USD\",\n\t\t}).format(price);\n\t}\n\n\t/**\n\t * Price-related operations\n\t */\n\tasync getPrice(request: { asset: string }) {\n\t\treturn this.priceService.getPrice(request);\n\t}\n\n\t/**\n\t * Option-related operations\n\t */\n\tasync getOptions(request: {\n\t\tasset: string;\n\t\toptionType: string;\n\t\tpositionType?: string;\n\t\tstrike?: number;\n\t\texpiry?: string;\n\t\tlimit?: number;\n\t}) {\n\t\treturn this.optionService.getOptions(request);\n\t}\n\n\t/**\n\t * Trading signal operations\n\t */\n\tasync generateSignals(request: {\n\t\tasset: string;\n\t\tbudget_usd: number;\n\t\ttrade_window_ms: number;\n\t\trisk_level: \"conservative\" | \"moderate\" | \"aggressive\";\n\t\tstrategy_focus: \"income\" | \"growth\" | \"hedging\";\n\t}) {\n\t\treturn this.signalService.generateSignals(request);\n\t}\n}\n\nexport { PriceService, OptionService, SignalService };\n","import type { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\nimport { elizaLogger } from \"@elizaos/core\";\n\nexport const grixEnvSchema = z.object({\n\tGRIX_API_KEY: z.string().min(1, \"Grix API key is required\"),\n\tOPENAI_API_KEY: z.string().min(1, \"OpenAI API key is required\"),\n});\n\nexport type GrixConfig = z.infer<typeof grixEnvSchema>;\n\n/**\n * Environment configuration validator\n * Ensures required API keys and settings are present\n */\nexport async function validateGrixConfig(runtime: IAgentRuntime): Promise<GrixConfig> {\n\telizaLogger.info(\"ðŸ” Validating Grix configuration...\");\n\ttry {\n\t\tconst config = {\n\t\t\tGRIX_API_KEY: runtime.getSetting(\"GRIX_API_KEY\"),\n\t\t\tOPENAI_API_KEY: runtime.getSetting(\"OPENAI_API_KEY\"),\n\t\t};\n\t\telizaLogger.info(\"Checking required settings...\");\n\n\t\tconst result = grixEnvSchema.parse(config);\n\t\telizaLogger.info(\"âœ… Configuration validated successfully\");\n\t\treturn result;\n\t} catch (error) {\n\t\telizaLogger.error(\"âŒ Configuration validation failed:\", error);\n\t\tif (error instanceof z.ZodError) {\n\t\t\tconst errorMessages = error.errors\n\t\t\t\t.map((err) => `${err.path.join(\".\")}: ${err.message}`)\n\t\t\t\t.join(\"\\n\");\n\t\t\tthrow new Error(`Grix configuration validation failed:\\n${errorMessages}`);\n\t\t}\n\t\tthrow error;\n\t}\n}\n","import {\n\ttype Action,\n\tcomposeContext,\n\telizaLogger,\n\tgenerateObjectDeprecated,\n\ttype HandlerCallback,\n\ttype IAgentRuntime,\n\ttype Memory,\n\tModelClass,\n\ttype State,\n} from \"@elizaos/core\";\nimport { GrixService } from \"../services\";\nimport { validateGrixConfig } from \"../environment\";\nimport { OptionResponse } from \"../services/option\";\n\nconst optionPriceTemplate = `Extract the cryptocurrency and option type from the user's request.\nIf option type is not specified, default to \"call\".\n\nExamples:\n- \"give me btc call options\" -> {\"asset\": \"BTC\", \"optionType\": \"call\", \"positionType\": \"long\"}\n- \"show eth put options\" -> {\"asset\": \"ETH\", \"optionType\": \"put\", \"positionType\": \"long\"}\n- \"check bitcoin options\" -> {\"asset\": \"BTC\", \"optionType\": \"call\", \"positionType\": \"long\"}\n- \"give me eth options\" -> {\"asset\": \"ETH\", \"optionType\": \"call\", \"positionType\": \"long\"}\n\nUser's request: \"{{recentMessages}}\"\n\nReturn ONLY a JSON object with the parameters:\n{\n    \"asset\": \"BTC\" or \"ETH\",\n    \"optionType\": \"call\" (default) or \"put\",\n    \"positionType\": \"long\" (default) or \"short\"\n}`;\n\ninterface OptionData {\n\tprotocol: string;\n\tavailable: number;\n\tprice: number;\n\texpiry: string;\n\tstrike: number;\n\ttype: string;\n}\n\nexport const getOptionPriceAction: Action = {\n\tname: \"GET_OPTION_PRICE\",\n\tsimiles: [\"CHECK_OPTIONS\", \"OPTION_PRICE\", \"OPTION_CHECK\", \"OPTIONS_DATA\"],\n\tdescription: \"Get current option prices for a cryptocurrency\",\n\tvalidate: async (runtime: IAgentRuntime) => {\n\t\ttry {\n\t\t\tawait validateGrixConfig(runtime);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t},\n\thandler: async (\n\t\truntime: IAgentRuntime,\n\t\tmessage: Memory,\n\t\tstate?: State,\n\t\t_options?: { [key: string]: unknown },\n\t\tcallback?: HandlerCallback\n\t): Promise<boolean> => {\n\t\ttry {\n\t\t\tconsole.log(\"ðŸš€ Starting getOptionPrice handler\");\n\t\t\telizaLogger.warn(\"ðŸš€ Starting getOptionPrice handler\");\n\n\t\t\tconst config = await validateGrixConfig(runtime);\n\t\t\tconst grixService = new GrixService({ apiKey: config.GRIX_API_KEY });\n\n\t\t\t// Update state with recent messages\n\t\t\tlet localState = state;\n\t\t\tlocalState = !localState\n\t\t\t\t? await runtime.composeState(message)\n\t\t\t\t: await runtime.updateRecentMessageState(localState);\n\n\t\t\t// Get recent conversation context\n\t\t\tconst recentMessages = composeContext({\n\t\t\t\tstate: localState,\n\t\t\t\ttemplate: \"{{conversation}}\",\n\t\t\t});\n\t\t\telizaLogger.warn(\"ðŸ“ Recent messages:\", recentMessages);\n\n\t\t\t// Get the actual user message\n\t\t\tconst userMessage = message.content.text;\n\t\t\telizaLogger.warn(\"ðŸ“ Processing user message:\", userMessage);\n\n\t\t\tconst extractedParams = await generateObjectDeprecated({\n\t\t\t\truntime,\n\t\t\t\tcontext: optionPriceTemplate.replace(\"{{recentMessages}}\", userMessage),\n\t\t\t\tmodelClass: ModelClass.SMALL,\n\t\t\t});\n\n\t\t\telizaLogger.warn(\"ðŸŽ¯ Raw extracted parameters:\", extractedParams);\n\n\t\t\t// Normalize the parameters\n\t\t\tconst normalizedParams = {\n\t\t\t\tasset: (extractedParams.asset || \"BTC\").toUpperCase(),\n\t\t\t\toptionType: (extractedParams.optionType || \"call\").toLowerCase(),\n\t\t\t\tpositionType: (extractedParams.positionType || \"long\").toLowerCase(),\n\t\t\t};\n\n\t\t\telizaLogger.warn(\"ðŸ”„ Normalized parameters:\", normalizedParams);\n\n\t\t\tconst result = await grixService.getOptions(normalizedParams);\n\n\t\t\telizaLogger.warn(\"âœ… Got options result:\", {\n\t\t\t\tasset: result.asset,\n\t\t\t\toptionCount: result.options.length,\n\t\t\t});\n\n\t\t\tconst responseText = formatOptionsResponse(result);\n\t\t\tif (callback) {\n\t\t\t\tawait callback({ text: responseText });\n\t\t\t}\n\n\t\t\tif (state) {\n\t\t\t\tstate.responseData = { text: responseText, action: \"GET_OPTION_PRICE\" };\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\telizaLogger.error(\"Error in option price handler:\", error);\n\t\t\tif (callback) {\n\t\t\t\tawait callback({\n\t\t\t\t\ttext: `Sorry, I couldn't get the option prices. Error: ${error}`,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\texamples: [\n\t\t[\n\t\t\t{\n\t\t\t\tuser: \"{{user1}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"Show me Bitcoin call options\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"I'll check the current Bitcoin call options for you.\",\n\t\t\t\t\taction: \"GET_OPTION_PRICE\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: `Available Options:\n\nExpiry: 2023-01-1\n\nBTC-29JAN1-50000-C\nProtocol: DERIVE\nAvailable: 10.5 contracts\nPrice: $1,250.50\n------------------------\n\nBTC-29JAN1-55000-C\nProtocol: ZOMMA\nAvailable: 5.2 contracts\nPrice: $980.25\n------------------------`,\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t],\n};\n\nfunction formatOptionsResponse(result: OptionResponse): string {\n\tif (!result.options || result.options.length === 0) {\n\t\treturn `No options data available for ${result.asset} ${result.optionType} options.`;\n\t}\n\n\t// First group by expiry\n\tconst groupedByExpiry = result.options.reduce((acc, opt) => {\n\t\tif (!acc[opt.expiry]) {\n\t\t\tacc[opt.expiry] = [];\n\t\t}\n\t\tacc[opt.expiry].push(opt);\n\t\treturn acc;\n\t}, {} as Record<string, any[]>);\n\n\tlet response = \"Available Options:\\n\";\n\n\tObject.entries(groupedByExpiry).forEach(([expiry, options]) => {\n\t\tresponse += `\\nExpiry: ${expiry}\\n`;\n\n\t\t// Group by symbol within each expiry\n\t\tconst groupedBySymbol = options.reduce((acc, option) => {\n\t\t\tconst date = new Date(option.expiry);\n\t\t\tconst day = date.getDate().toString().padStart(2, \"0\");\n\t\t\tconst month = date.toLocaleString(\"en-US\", { month: \"short\" }).toUpperCase();\n\t\t\tconst year = date.getFullYear().toString().slice(-2);\n\t\t\tconst symbol = `${result.asset}-${day}${month}${year}-${\n\t\t\t\toption.strike\n\t\t\t}-${option.type.charAt(0)}`;\n\n\t\t\tif (!acc[symbol]) {\n\t\t\t\tacc[symbol] = [];\n\t\t\t}\n\t\t\tacc[symbol].push(option);\n\t\t\treturn acc;\n\t\t}, {} as Record<string, OptionData[]>);\n\n\t\t// Format each symbol group\n\t\t(Object.entries(groupedBySymbol) as [string, OptionData[]][]).forEach(\n\t\t\t([symbol, symbolOptions]) => {\n\t\t\t\tresponse += `\\n${symbol}\\n`;\n\t\t\t\tsymbolOptions.forEach((option) => {\n\t\t\t\t\tresponse += `Protocol: ${option.protocol}\\n`;\n\t\t\t\t\tresponse += `Available: ${option.available} contracts\\n`;\n\t\t\t\t\tresponse += `Price: $${option.price.toLocaleString()}\\n`;\n\t\t\t\t});\n\t\t\t\tresponse += `------------------------\\n`;\n\t\t\t}\n\t\t);\n\t});\n\n\treturn response.trim();\n}\n","import {\n\ttype Action,\n\tcomposeContext,\n\telizaLogger,\n\tgenerateObjectDeprecated,\n\ttype HandlerCallback,\n\ttype IAgentRuntime,\n\ttype Memory,\n\tModelClass,\n\ttype State,\n} from \"@elizaos/core\";\nimport { GrixService } from \"../services\";\nimport { validateGrixConfig } from \"../environment\";\n\nconst tradingSignalTemplate = `Extract trading parameters from the user's request.\nIf parameters are not specified, use defaults.\n\nThe user might request trading signals in many different ways. Here are examples with their expected parameters:\n\n- \"Generate BTC trading signals with $5000 budget\" -> \n  {\"asset\": \"BTC\", \"budget_usd\": 5000, \"risk_level\": \"moderate\", \"strategy_focus\": \"growth\"}\n\n- \"Give me conservative ETH signals for $10000\" -> \n  {\"asset\": \"ETH\", \"budget_usd\": 10000, \"risk_level\": \"conservative\", \"strategy_focus\": \"safety\"}\n\n- \"What should I trade with $25000?\" -> \n  {\"asset\": \"BTC\", \"budget_usd\": 25000, \"risk_level\": \"moderate\", \"strategy_focus\": \"growth\"}\n\n- \"Need safe trading ideas for BTC\" -> \n  {\"asset\": \"BTC\", \"budget_usd\": 10000, \"risk_level\": \"conservative\", \"strategy_focus\": \"safety\"}\n\nLook for these indicators:\n- Asset: BTC/Bitcoin or ETH/Ethereum\n- Budget: Dollar amounts like $5000, 10k, etc.\n- Risk Level: conservative/safe, moderate/normal, aggressive/risky\n- Strategy: growth/profit, safety/protection, yield/income\n\nDefaults:\n- asset: \"BTC\"\n- budget_usd: 10000\n- risk_level: \"moderate\"\n- strategy_focus: \"growth\"\n\nUser's request: \"{{recentMessages}}\"\n\nReturn ONLY a JSON object with the parameters:\n{\n    \"asset\": \"BTC\" or \"ETH\",\n    \"budget_usd\": number (default: 10000),\n    \"risk_level\": \"conservative\" or \"moderate\" or \"aggressive\",\n    \"strategy_focus\": \"growth\" or \"safety\" or \"yield\"\n}`;\n\nexport class GetTradingSignalAction implements Action {\n\tname = \"GET_TRADING_SIGNAL\";\n\tdescription = \"Generate trading signals based on market conditions\";\n\tsimiles = [\"generate signals\", \"trading advice\", \"options strategy\", \"investment ideas\"];\n\n\texamples = [\n\t\t[\n\t\t\t{\n\t\t\t\tuser: \"{{user}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"Generate trading signals for BTC with $25,000 budget\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"I'll generate Bitcoin trading signals for a $25,000 budget.\",\n\t\t\t\t\taction: \"GET_TRADING_SIGNAL\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"Here are my recommended trading signals based on a budget of $25,000:\\n\\n1. OPEN LONG position on BTC-30JUN23-40000-C at $1,250\\n   Reason: Bullish momentum with strong support at current levels\\n   Confidence: 75%\\n\\n2. OPEN SHORT position on BTC-30JUN23-50000-C at $420\\n   Reason: Overpriced premium relative to probability of reaching strike\\n   Confidence: 65%\\n\\nThese signals are based on current market conditions and should be considered as suggestions, not financial advice.\",\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t];\n\n\tasync validate(runtime: IAgentRuntime): Promise<boolean> {\n\t\ttry {\n\t\t\tawait validateGrixConfig(runtime);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tasync handler(\n\t\truntime: IAgentRuntime,\n\t\tmessage: Memory,\n\t\tstate?: State,\n\t\t_options?: { [key: string]: unknown },\n\t\tcallback?: HandlerCallback\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\tconst config = await validateGrixConfig(runtime);\n\t\t\tconst grixService = new GrixService({ apiKey: config.GRIX_API_KEY });\n\n\t\t\t// Initialize or update state\n\t\t\tlet localState = state;\n\t\t\tlocalState = !localState\n\t\t\t\t? await runtime.composeState(message)\n\t\t\t\t: await runtime.updateRecentMessageState(localState);\n\n\t\t\tconst recentMessages = composeContext({\n\t\t\t\tstate: localState,\n\t\t\t\ttemplate: \"{{conversation}}\",\n\t\t\t});\n\n\t\t\t// Use LLM to extract parameters from user message\n\t\t\tconst extractedParams = await generateObjectDeprecated({\n\t\t\t\truntime,\n\t\t\t\tcontext: tradingSignalTemplate.replace(\"{{recentMessages}}\", message.content.text),\n\t\t\t\tmodelClass: ModelClass.SMALL,\n\t\t\t});\n\n\t\t\telizaLogger.warn(\"ðŸŽ¯ Extracted signal parameters:\", extractedParams);\n\n\t\t\tconst normalizedParams = {\n\t\t\t\tasset: (extractedParams.asset || \"BTC\").toUpperCase(),\n\t\t\t\tbudget_usd: extractedParams.budget_usd || 10000,\n\t\t\t\trisk_level: extractedParams.risk_level || \"moderate\",\n\t\t\t\tstrategy_focus: extractedParams.strategy_focus || \"growth\",\n\t\t\t};\n\n\t\t\t// Get signals from service\n\t\t\tconst result = await grixService.generateSignals({\n\t\t\t\tasset: normalizedParams.asset,\n\t\t\t\tbudget_usd: normalizedParams.budget_usd,\n\t\t\t\trisk_level: normalizedParams.risk_level,\n\t\t\t\tstrategy_focus: normalizedParams.strategy_focus,\n\t\t\t\ttrade_window_ms: 7 * 24 * 60 * 60 * 1000, // 1 week in milliseconds\n\t\t\t});\n\n\t\t\t// Format the response\n\t\t\tconst responseText = this.formatTradingSignals(result, normalizedParams.budget_usd);\n\n\t\t\tif (callback) {\n\t\t\t\tawait callback({\n\t\t\t\t\ttext: responseText,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (state) {\n\t\t\t\tstate.responseData = { text: responseText, action: this.name };\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\telizaLogger.error(\"Error in trading signal action handler:\", error);\n\n\t\t\tif (callback) {\n\t\t\t\tawait callback({\n\t\t\t\t\ttext: `Sorry, I couldn't generate trading signals. Error: ${error}`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tformatTradingSignals(result: any, budget: number): string {\n\t\tlet response = `Here are my recommended trading signals based on a budget of $${budget.toLocaleString()}:\\n\\n`;\n\n\t\tif (!result.signals || result.signals.length === 0) {\n\t\t\treturn response + \"No viable trading signals found for the current market conditions.\";\n\t\t}\n\n\t\tresult.signals.forEach((signal: any, index: number) => {\n\t\t\tresponse += `${\n\t\t\t\tindex + 1\n\t\t\t}. ${signal.action_type.toUpperCase()} ${signal.position_type.toUpperCase()} position on ${\n\t\t\t\tsignal.instrument\n\t\t\t} at $${signal.expected_instrument_price_usd.toLocaleString()}\\n`;\n\t\t\tresponse += `   Reason: ${signal.reason}\\n`;\n\n\t\t\tif (signal.confidence_score) {\n\t\t\t\tresponse += `   Confidence: ${Math.round(signal.confidence_score * 100)}%\\n`;\n\t\t\t}\n\n\t\t\tresponse += \"\\n\";\n\t\t});\n\n\t\tresponse +=\n\t\t\t\"These signals are based on current market conditions and should be considered as suggestions, not financial advice.\";\n\t\treturn response;\n\t}\n}\n\nexport const getTradingSignalAction = new GetTradingSignalAction();\n","import type { Action, IAgentRuntime, Memory, State, HandlerCallback } from \"@elizaos/core\";\n\nexport class ShowGrixHelpAction implements Action {\n\tname = \"SHOW_GRIX_HELP\";\n\tdescription = \"Shows available Grix commands and examples\";\n\tsimiles = [\n\t\t\"grix help\",\n\t\t\"trading help\",\n\t\t\"options help\",\n\t\t\"show commands\",\n\t\t\"menu\",\n\t\t\"what can you do\",\n\t\t\"show me what you can do\",\n\t];\n\n\texamples = [\n\t\t[\n\t\t\t{\n\t\t\t\tuser: \"{{user}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"Show me what you can do\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: \"Here's what I can help you with:\",\n\t\t\t\t\taction: \"SHOW_GRIX_HELP\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tuser: \"{{agent}}\",\n\t\t\t\tcontent: {\n\t\t\t\t\ttext: '# ðŸ¤– Grix Trading Assistant\\n\\nHere are some examples of what you can ask me:\\n\\n## ðŸ“Š Price Information\\n- \"What\\'s the current BTC price?\"\\n- \"Show me ETH price\"\\n\\n## ðŸ“ˆ Options Trading\\n- \"Find me BTC calls\"\\n- \"Show ETH put options\"\\n- \"What are the best BTC options right now?\"\\n\\n*Just type any of these questions or ask in your own words!*',\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t];\n\n\tvalidate = async (_runtime: IAgentRuntime): Promise<boolean> => {\n\t\treturn true; // Always available since it doesn't require external APIs\n\t};\n\n\tasync handler(\n\t\t_runtime: IAgentRuntime,\n\t\t_message: Memory,\n\t\tstate?: State,\n\t\t_options?: Record<string, unknown>,\n\t\tcallback?: HandlerCallback\n\t): Promise<boolean> {\n\t\tconst helpText = `# ðŸ¤– Grix Trading Assistant\n\nHere are some examples of what you can ask me:\n\n## ðŸ“Š Price Information\n- \"What's the current BTC price?\"\n- \"Show me ETH price\"\n\n## ðŸ“ˆ Options Trading\n- \"Find me BTC calls\"\n- \"Show ETH put options\" \n- \"What are the best BTC options right now?\"\n\n## ðŸ“‹ Trading Signals\n- \"Generate trading signals for BTC\"\n- \"What should I trade with $25,000?\"\n- \"Give me conservative ETH trading ideas\"\n\n*Just type any of these questions or ask in your own words!*`;\n\n\t\tif (callback) {\n\t\t\tawait callback({ text: helpText, action: this.name });\n\t\t}\n\n\t\tif (state) {\n\t\t\tstate.responseData = { text: helpText, action: this.name };\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nexport const showGrixHelpAction = new ShowGrixHelpAction();\n","import type { Plugin } from \"@elizaos/core\";\nimport { elizaLogger } from \"@elizaos/core\";\n\nimport { getAssetPriceAction } from \"./actions/getAssetPrice\";\nimport { getOptionPriceAction } from \"./actions/getOptionPrice\";\nimport { getTradingSignalAction } from \"./actions/getTradingSignal\";\nimport { showGrixHelpAction } from \"./actions/showGrixHelp\";\n\n/**\n * Grix Finance Plugin v2\n * Provides cryptocurrency price feeds, options data, and trading signals\n *\n * This plugin follows a service-oriented architecture with:\n * - Specialized services with clear responsibilities\n * - Clean separation between services and actions\n * - Standardized error handling\n * - Consistent parameter validation\n */\n\n// Configure logger to show all levels\n\nexport const grixPlugin: Plugin = {\n\tname: \"grixv2\",\n\tdescription: \"Grix Finance Plugin v2 - Advanced crypto options trading insights and signals\",\n\tactions: [\n\t\tgetAssetPriceAction,\n\t\tgetOptionPriceAction,\n\t\tgetTradingSignalAction,\n\t\tshowGrixHelpAction,\n\t],\n\t// Removed evaluators since actions now handle parameter extraction\n\tevaluators: [],\n\tproviders: [],\n};\n\nexport default grixPlugin;\n\n// Re-export all actions for external use\nexport * from \"./actions\";\n"],"mappings":"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","names":["elizaLogger","elizaLogger","response","elizaLogger","elizaLogger","elizaLogger","composeContext","elizaLogger","generateObjectDeprecated","ModelClass","elizaLogger","composeContext","generateObjectDeprecated","ModelClass","composeContext","elizaLogger","generateObjectDeprecated","ModelClass","composeContext","generateObjectDeprecated","ModelClass","elizaLogger"]}